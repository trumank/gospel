use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::rc::Rc;
use anyhow::{anyhow, bail};
use gospel_compiler::ast::ExpressionValueType;
use gospel_compiler::backend::{CompilerFunctionReference, CompilerInstance, CompilerLexicalNode, CompilerLexicalScope, CompilerLexicalScopeClass, CompilerOptions};
use gospel_compiler::module_definition::resolve_module_dependencies;
use gospel_vm::module::GospelContainer;
use gospel_vm::vm::{GospelVMOptions, GospelVMRunContext, GospelVMState, GospelVMValue};

#[derive(Debug)]
pub(crate) struct ResolvedBindingsModuleContext {
    pub(crate) run_context: GospelVMRunContext,
    pub(crate) type_name_to_dependency_crate_name: HashMap<String, Option<String>>,
    pub(crate) type_name_to_type_index: Vec<(String, Option<usize>, bool)>,
}

pub(crate) fn process_module_context(main_module_path: &PathBuf, additional_dependencies: &Vec<PathBuf>, extra_modules_to_include: &HashSet<String>, module_to_bindings_crate: &HashMap<String, String>) -> anyhow::Result<ResolvedBindingsModuleContext> {
    let mut all_module_paths: Vec<PathBuf> = Vec::new();
    all_module_paths.push(main_module_path.clone());
    all_module_paths.append(&mut additional_dependencies.clone());

    let main_module = resolve_module_dependencies(&all_module_paths).map_err(|x| anyhow!("Failed to resolve module dependencies: {}", x))?[0].clone();
    let compiler_instance = CompilerInstance::create(CompilerOptions::default().allow_partial_types().generate_prototype_layouts());

    // Compile module dependencies and main module
    let all_module_dependencies = main_module.get_all_module_dependencies();
    let mut compiled_module_dependencies: Vec<GospelContainer> = Vec::new();
    for module_dependency in &all_module_dependencies {
        compiled_module_dependencies.push(module_dependency.compile_module(&compiler_instance).map_err(|x| anyhow!("Failed to compile module dependency: {}", x))?);
    }
    let compiled_main_module = main_module.compile_module(&compiler_instance).map_err(|x| anyhow!("Failed to compile module: {}", x))?;

    let mut type_name_to_dependency_crate_name: HashMap<String, Option<String>> = HashMap::new();
    let mut type_definition_functions: Vec<CompilerFunctionReference> = Vec::new();

    // Gather all type definitions produced by the modules
    for module_dependency in &all_module_dependencies {
        let module_name = module_dependency.module_name().to_string();
        if let Some(dependency_scope) = compiler_instance.find_module_scope(&module_name) {
            let source_crate = module_to_bindings_crate.get(&module_name);
            let is_included_with_this_module = extra_modules_to_include.contains(&module_name);

            if source_crate.is_some() && !is_included_with_this_module {
                discover_module_type_definitions(&dependency_scope, Some(source_crate.unwrap().as_str()), &mut type_name_to_dependency_crate_name, &mut Vec::new());
            } else if source_crate.is_none() && is_included_with_this_module {
                discover_module_type_definitions(&dependency_scope, None, &mut type_name_to_dependency_crate_name, &mut type_definition_functions);
            } else if source_crate.is_some() && is_included_with_this_module {
                bail!("Module {} bindings are already defined in crate {}, but it was asked to be included in this module bindings", module_name, source_crate.unwrap());
            } else {
                bail!("Module {} is a dependency of module {}, but it is not generated by any other crate and is not included in this module bindings", module_name, &main_module.module_name());
            }
        }
    }

    // Process type definitions produced by the main module as well
    if let Some(existing_module_crate) = module_to_bindings_crate.get(main_module.module_name()) {
        bail!("Module {} bindings are already generated in a dependency crate {}", main_module.module_name(), existing_module_crate);
    }
    if let Some(main_module_scope) = compiler_instance.find_module_scope(main_module.module_name()) {
        discover_module_type_definitions(&main_module_scope, None, &mut type_name_to_dependency_crate_name, &mut type_definition_functions);
    } else {
        bail!("Module {} did not contain any source files to be compiled", main_module.module_name());
    }

    // Mount all module containers to the VM state
    let mut vm_state = GospelVMState::create();
    for module_container in compiled_module_dependencies {
        vm_state.mount_container(module_container).map_err(|x| anyhow!("Failed to mount dependency module container: {}", x))?;
    }
    vm_state.mount_container(compiled_main_module).map_err(|x| anyhow!("Failed to mount dependency module container: {}", x))?;

    // Run the VM to generate type hierarchy for types that we want to generate
    let mut run_context = GospelVMRunContext::create(GospelVMOptions::default().no_default_globals());
    let mut type_name_to_type_index: Vec<(String, Option<usize>, bool)> = Vec::new();
    for function_reference in &type_definition_functions {
        let type_name = function_reference.return_value_type_name.as_ref().unwrap().clone();
        if let Some(type_function) = vm_state.find_function_by_reference(&function_reference.function) &&
            let execution_result = type_function.execute(Vec::new(), &mut run_context).map_err(|x| anyhow!("Failed to evaluate type {}: {}", &type_name, x))? &&
            let GospelVMValue::TypeReference(type_index) = execution_result {
            let is_parameterless_type = function_reference.signature.explicit_parameters.is_none() && function_reference.signature.implicit_parameters.is_empty();
            type_name_to_type_index.push((type_name, Some(type_index), is_parameterless_type));
        } else {
            type_name_to_type_index.push((type_name, None, false));
        }
    }

    Ok(ResolvedBindingsModuleContext{ run_context, type_name_to_dependency_crate_name, type_name_to_type_index })
}

fn discover_module_type_definitions(current_scope: &Rc<CompilerLexicalScope>, crate_name: Option<&str>, type_name_to_crate_name: &mut HashMap<String, Option<String>>, type_definition_functions: &mut Vec<CompilerFunctionReference>) {
    for child_node in current_scope.iterate_children() {
        if let CompilerLexicalNode::Scope(child_scope) = child_node {
            if let CompilerLexicalScopeClass::Function(function_declaration) = &child_scope.class {
                let function_reference = function_declaration.borrow().function_reference.clone();
                if function_reference.signature.return_value_type == ExpressionValueType::Typename && let Some(return_value_type_name) = &function_reference.return_value_type_name {
                    type_name_to_crate_name.insert(return_value_type_name.clone(), crate_name.map(|x| x.to_string()));
                    type_definition_functions.push(function_reference);
                }
            } else if matches!(child_scope.class, CompilerLexicalScopeClass::SourceFile(_)) || matches!(child_scope.class, CompilerLexicalScopeClass::Namespace) {
                discover_module_type_definitions(&child_scope, crate_name, type_name_to_crate_name, type_definition_functions);
            }
        }
    }
}
