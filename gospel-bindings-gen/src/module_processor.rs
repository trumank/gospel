use std::collections::{HashMap, HashSet};
use std::path::PathBuf;
use std::rc::Rc;
use anyhow::{anyhow, bail};
use gospel_compiler::ast::ExpressionValueType;
use gospel_compiler::backend::{CompilerFunctionDeclaration, CompilerInstance, CompilerLexicalNode, CompilerLexicalScope, CompilerLexicalScopeClass, CompilerOptions};
use gospel_compiler::module_definition::resolve_module_dependencies;
use gospel_vm::module::GospelContainer;
use gospel_vm::vm::{GospelVMOptions, GospelVMRunContext, GospelVMState, GospelVMValue};

#[derive(Debug, Clone)]
pub(crate) struct BindingsTypeDefinition {
    pub(crate) type_full_name: String,
    pub(crate) type_index: Option<usize>,
    pub(crate) function_declaration: Option<CompilerFunctionDeclaration>,
}
impl BindingsTypeDefinition {
    pub(crate) fn is_parameterless_type(&self) -> bool {
        if let Some(declaration) = &self.function_declaration {
            declaration.reference.signature.explicit_parameters.is_none() && declaration.reference.signature.implicit_parameters.is_empty()
        } else { false }
    }
}

#[derive(Debug)]
pub(crate) struct ResolvedBindingsModuleContext {
    pub(crate) run_context: GospelVMRunContext,
    pub(crate) type_source_crate_lookup: HashMap<String, Option<String>>,
    // Not actually dead, needed to keep weak pointers alive
    #[allow(dead_code)]
    pub(crate) compiler_instance: Rc<CompilerInstance>,
    pub(crate) types_to_generate: Vec<BindingsTypeDefinition>,
}

pub(crate) fn process_module_context(main_module_path: &PathBuf, additional_dependencies: &Vec<PathBuf>, extra_modules_to_include: &HashSet<String>, module_to_bindings_crate: &HashMap<String, String>) -> anyhow::Result<ResolvedBindingsModuleContext> {
    let mut all_module_paths: Vec<PathBuf> = Vec::new();
    all_module_paths.push(main_module_path.clone());
    all_module_paths.append(&mut additional_dependencies.clone());

    let main_module = resolve_module_dependencies(&all_module_paths).map_err(|x| anyhow!("Failed to resolve module dependencies: {}", x))?[0].clone();
    let compiler_instance = CompilerInstance::create(CompilerOptions::default().allow_partial_types().generate_prototype_layouts());

    // Compile module dependencies and main module
    let all_module_dependencies = main_module.get_all_module_dependencies();
    let mut compiled_module_dependencies: Vec<GospelContainer> = Vec::new();
    for module_dependency in &all_module_dependencies {
        compiled_module_dependencies.push(module_dependency.compile_module(&compiler_instance).map_err(|x| anyhow!("Failed to compile module dependency: {}", x))?);
    }
    let compiled_main_module = main_module.compile_module(&compiler_instance).map_err(|x| anyhow!("Failed to compile module: {}", x))?;

    let mut type_source_crate_lookup: HashMap<String, Option<String>> = HashMap::new();
    let mut type_definition_functions: Vec<CompilerFunctionDeclaration> = Vec::new();

    // Gather all type definitions produced by the modules
    for module_dependency in &all_module_dependencies {
        let module_name = module_dependency.module_name().to_string();
        if let Some(dependency_scope) = compiler_instance.find_module_scope(&module_name) {
            let source_crate = module_to_bindings_crate.get(&module_name);
            let is_included_with_this_module = extra_modules_to_include.contains(&module_name);

            if source_crate.is_some() && !is_included_with_this_module {
                discover_module_type_definitions(&dependency_scope, Some(source_crate.unwrap().as_str()), &mut type_source_crate_lookup, &mut Vec::new());
            } else if source_crate.is_none() && is_included_with_this_module {
                discover_module_type_definitions(&dependency_scope, None, &mut type_source_crate_lookup, &mut type_definition_functions);
            } else if source_crate.is_some() && is_included_with_this_module {
                bail!("Module {} bindings are already defined in crate {}, but it was asked to be included in this module bindings", module_name, source_crate.unwrap());
            } else {
                bail!("Module {} is a dependency of module {}, but it is not generated by any other crate and is not included in this module bindings", module_name, &main_module.module_name());
            }
        }
    }

    // Process type definitions produced by the main module as well
    if let Some(existing_module_crate) = module_to_bindings_crate.get(main_module.module_name()) {
        bail!("Module {} bindings are already generated in a dependency crate {}", main_module.module_name(), existing_module_crate);
    }
    if let Some(main_module_scope) = compiler_instance.find_module_scope(main_module.module_name()) {
        discover_module_type_definitions(&main_module_scope, None, &mut type_source_crate_lookup, &mut type_definition_functions);
    } else {
        bail!("Module {} did not contain any source files to be compiled", main_module.module_name());
    }

    // Mount all module containers to the VM state
    let mut vm_state = GospelVMState::create();
    for module_container in compiled_module_dependencies {
        vm_state.mount_container(module_container).map_err(|x| anyhow!("Failed to mount dependency module container: {}", x))?;
    }
    vm_state.mount_container(compiled_main_module).map_err(|x| anyhow!("Failed to mount dependency module container: {}", x))?;

    // Run the VM to generate type hierarchy for types that we want to generate
    let mut run_context = GospelVMRunContext::create(GospelVMOptions::default().no_default_globals());
    let mut types_to_generate: Vec<BindingsTypeDefinition> = Vec::new();
    for function_declaration in &type_definition_functions {
        let type_name = function_declaration.reference.return_value_type_name.as_ref().unwrap().clone();
        if let Some(type_function) = vm_state.find_function_by_reference(&function_declaration.reference.function) &&
            let execution_result = type_function.execute(Vec::new(), &mut run_context).map_err(|x| anyhow!("Failed to evaluate type {}: {}", &type_name, x))? &&
            let GospelVMValue::TypeReference(type_index) = execution_result {
            types_to_generate.push(BindingsTypeDefinition{
                type_full_name: type_name,
                type_index: Some(type_index),
                function_declaration: Some(function_declaration.clone()),
            });
        } else {
            types_to_generate.push(BindingsTypeDefinition{
                type_full_name: type_name,
                type_index: None,
                function_declaration: None,
            })
        }
    }

    Ok(ResolvedBindingsModuleContext{ run_context, type_source_crate_lookup, compiler_instance, types_to_generate })
}

fn discover_module_type_definitions(current_scope: &Rc<CompilerLexicalScope>, crate_name: Option<&str>, type_name_to_crate_name: &mut HashMap<String, Option<String>>, type_definition_functions: &mut Vec<CompilerFunctionDeclaration>) {
    for child_node in current_scope.iterate_children() {
        if let CompilerLexicalNode::Scope(child_scope) = child_node {
            if let CompilerLexicalScopeClass::Function(function_declaration) = &child_scope.class {
                let function_declaration = function_declaration.borrow().clone();
                if function_declaration.reference.signature.return_value_type == ExpressionValueType::Typename && let Some(return_value_type_name) = &function_declaration.reference.return_value_type_name {
                    type_name_to_crate_name.insert(return_value_type_name.clone(), crate_name.map(|x| x.to_string()));
                    type_definition_functions.push(function_declaration);
                }
            } else if matches!(child_scope.class, CompilerLexicalScopeClass::SourceFile(_)) || matches!(child_scope.class, CompilerLexicalScopeClass::Namespace) {
                discover_module_type_definitions(&child_scope, crate_name, type_name_to_crate_name, type_definition_functions);
            }
        }
    }
}
