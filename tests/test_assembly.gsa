global test_global = 5;
extern global external_global;

constant assembly_version = 1;

function InvokerType invoke: Closure -> TypeReference {
    LoadSlot invoke;
    Call 0;
    SetReturnValue;
};

function ClosureCallFunction first: Integer second: Integer -> Integer {
    LoadSlot first;
    LoadSlot second;
    Add;
    SetReturnValue;
};

function ClosureTest -> Integer {
    LoadSlot &function ClosureCallFunction;
    IntConstant 5;
    BindClosure 1;
A:  Slot Closure;
    StoreSlot A;
    IntConstant 7;
    LoadSlot A;
    Call 1;
    SetReturnValue;
};

function ArrayTest -> Array {
    ArrayAllocate;
    IntConstant 3;
    ArrayReserve;
    IntConstant 15;
    ArrayPushItem;
    IntConstant 0;
    IntConstant 10;
    ArrayInsertItem;
    Dup;
    Dup;
    ArrayGetLength;
    IntConstant 1;
    Sub;
    ArrayGetItem;
    IntConstant 1;
    Add;
    ArrayPushItem;
    SetReturnValue;
};

function AbortTest -> Integer {
    RaiseException "abort test";
};

structure TestStruct {
    named_field: Integer;
    test_field: Integer;
    Integer;
};

hidden structure LocalStruct {
    Integer;
};

function StructTest -> Struct {
    StructAllocate TestStruct;
    IntConstant 15;
    StructSetLocalField TestStruct 0;
    IntConstant 10;
    StructSetNamedField TestStruct "test_field";
    Dup;
    Dup;
    StructGetLocalField TestStruct 1;
A:  Slot Integer;
    StoreSlot A;
    StructGetNamedField TestStruct "named_field";
    LoadSlot A;
    Mul;
    StructSetLocalField TestStruct 2;
    SetReturnValue;
};

function LocalStructTest -> Struct {
    StructAllocate structure LocalStruct;
    IntConstant 20;
    StructSetLocalField structure LocalStruct 0;
    SetReturnValue;
};

function ExceptionHandlerTest value: Integer -> Integer {
    IntConstant 5;
    PushExceptionHandler A;
    Pop;
    IntConstant 2;
    LoadSlot value;
    IntConstant 1;
    Sub;
    Ez;
    Branchz B;
    RaiseException "Value of 1 is bad";
B:  PopExceptionHandler;
    Branch C;
A:  IntConstant 1;
    Sub;
C:  SetReturnValue;
};
